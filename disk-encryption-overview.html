<!DOCTYPE html>
<html lang="en">
<head>
        <title>Disk Encryption Overview</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css" />
        <link rel="stylesheet" href="./theme/css/main.css" />
	<link rel="stylesheet" href="./css/autumn.css" />
        <link href="https://alipullup.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Ali's Posts Full Atom Feed" />
        <link href="https://alipullup.github.io/feeds/misc.atom.xml" type="application/atom+xml" rel="alternate" title="Ali's Posts Categories Atom Feed" />
</head>
<body>

    <div class="navigation pure-menu pure-menu-horizontal">
        <a href="./" class="pure-menu-heading  pure-menu-link">Ali's Posts</a>
        <ul class="pure-menu-list">
            <li class="pure-menu-item"></li>
            <li class="pure-menu-item"><a href="/archives.html" class="pure-menu-link">Archives</a></li>
            <li class="pure-menu-item"><a href="/categories.html" class="pure-menu-link">Categories</a></li>
            <li class="pure-menu-item"><a href="/tags.html" class="pure-menu-link">Tags</a></li>

            <li class="pure-menu-item"><a href="./pages/about-me.html" class="pure-menu-link">About me</a></li>
        </ul>
    </div>


<div class="page-container">
    <div class="entry-content">
        <div class="post-meta pure-g">
<div class="pure-u-3-4 meta-data">
    <a href="./category/misc.html" class="category">misc</a><br />

    <a class="author" href="./author/ali-imran.html">Ali Imran</a>
    &mdash; <abbr title="2008-09-16T00:00:00-04:00">Tue 16 September 2008</abbr>
</div>        </div>
    </div>

    <div class="article-header-container">
        <div class="background-image-container">

            <div class="background-image-small">
                <div class="title-container">
                    <h1>Disk Encryption Overview</h1>
                </div>
            </div>
        </div>
    </div>

    <div class="entry-content">
        <h1>Introduction</h1>
<p>This document describes disk encryption implemented using a combination of software and FPGA.</p>
<div class="codehilite"><pre><span></span>--Data--&gt;FPGA--&gt;Disks
           |
    Microcontroller
</pre></div>


<p>The data was encrypted using AES, in counter mode, with flexible key width.</p>
<p>For various reasons, we did not use an <a href="https://en.wikipedia.org/wiki/Authenticated_encryption">authenticated encryption</a> mode.</p>
<p>A FPGA was responsible for encryption, to keep up with the high data rate. Control software running on a microcontroller was responsible for loading up the AES key schedule during bulk streaming operations.</p>
<p>During normal operations, the microcontroller went <em>through</em> the FPGA to access the disks. Software running on the microcontroller was responsible for managing the disks otherwise.</p>
<h1>Encryption Overview</h1>
<p>We encrypt all data before writing to disk. There are two reasons for
doing this:</p>
<ol>
<li>Quick erase: destroy all data by destroying the keys.</li>
<li>Secure transport: securely transport the disks by transmitting the keys separately.</li>
</ol>
<p>We begin by describing how data flows through the system, and then how quick erase and secure transport are implemented.</p>
<h2>Data Flow Models</h2>
<p><img alt="Encryption Data Flow" src="images/encryption_overview_data_flow.png" /></p>
<h2>Encryption pseudo-code</h2>
<p>This is a simplified way of looking at encryption: a function is given
data from a disk, and it encrypts that data and writes it out. In
reality, this done in parallel by the FPGA.</p>
<div class="codehilite"><pre><span></span>    Encrypt_Disk_Data (Meta  : Metadata, 
                       Sess  : Session_Info,
                       D     : int, -- disk number
                       Data  : UINT128[])
     --  Depending on Meta.Mode, this will either read a key 
     --  from disk, or read a key from the disk and combine it
     --  with a key from removable storage.
     Key : UINT128 := Get_Disk_Key (Meta, D);
     --  Initialize encryption context using the given key.
     Ctx : Aes_Context_Type := AES_Initialize (Key);
     --  The counter is a 128-bit value that is derived using:
     --  - The disk seed for disk D, which was originally derived 
     --    from the disk serial number.
     --  - The session seed, which is a random 64-bit number, 
     --    chosen session creation.
     Counter := Initialize_Counter (Meta, Sess, D);
     For I = 0 to length (Data) loop
       Increment_Counter (Counter);
       E : UINT128 := AES_Counter_Encrypt (Ctx, Counter, Data[I]);
       Disk_Write (D, I, E);
     End;
</pre></div>


<p>Where:</p>
<ul>
<li><code>UINT128</code> is an unsigned 128-bit quantity.</li>
<li><code>Data</code> is an array of 128-bit values.</li>
<li><code>Get_Disk_Key</code>, <code>AES_Initialize</code>, <code>AES_Counter_Encrypt</code>,
  <code>Initialize_Counter</code>, <code>Increment_Counter</code>, and <code>Disk_Write</code>
  are external functions.</li>
</ul>
<h1>Critical Analysis</h1>
<p>A formal security proof is not presented here. However, it is noted
that the security of data on disks depends entirely upon:</p>
<ol>
<li>Disk keys used for encryption. Below we will lay out the threat
   model we protect against.</li>
<li>Counter value. We&rsquo;ve taken care to ensure that the counter is
   globally unique. This is addressed in the section titled <code>Counter</code>
   above.</li>
<li>AES implementation. The FPGA implementation has been tested with
   known vectors, and also been verified by decrypting the data with a
   known-good software implementation. We talk some more about this
   below in <code>Encryption Primitives Used</code>.</li>
<li>AES usage. We&rsquo;re using the well known counter mode for AES. In the
   section <code>Counter mode weaknesses</code> we talk about this some more.</li>
</ol>
<h2>Threat Model</h2>
<p>We assume that the recorder operates in a secure environment. Thus
there are no protections against physical attacks.</p>
<p>(REMOVED)</p>
<h2>Encryption Primitives Used</h2>
<p>The following encryption primitives are used. We
also given some implementation details:</p>
<ul>
<li><strong>AES(FGPA)</strong>: A hardware (FPGA) implementation of AES is used
  for encryption of optical data.</li>
<li><strong>AES(C)</strong>: A reference implementation of AES (written in the
  <code>C</code> programming language) is used by the software to encrypt metadata written to disk.</li>
<li><strong>SHA256</strong>:  (REMOVED)</li>
<li><strong>SHA256 HMAC</strong>: (REMOVED)</li>
<li><strong>MD5</strong>: (REMOVED)</li>
<li><strong>(REMOVED) RNG</strong>: The (REMOVED) random number generator is  used to generate:<ul>
<li>The per-disk keys during initial formatting.</li>
<li>The session ID start during initial formatting (XX-bit number, see <code>Software Entities</code>).</li>
<li>The session seed during session creation (YY-bit number, see <code>Software Entities</code>).</li>
</ul>
</li>
</ul>
<h2>Counter mode weaknesses</h2>
<ul>
<li><strong>Data integrity</strong>: Counter mode doesn&rsquo;t provide any message
  integrity. There is no MAC used, thus it
  possible to change the data on disk.</li>
<li><strong>Key reuse</strong>: The key is randomly generated, and given a good RNG,
  the probability of key use is extremely low.</li>
<li><strong>Counter uniqueness</strong>: The counter is chosen to be globally unique. Thus it is very unlikely that the same counter is used for two separate sessions.</li>
</ul>
<h2>Entropy</h2>
<p>Entropy in an embedded environment is a difficult problem. The system may be rebooted frequently and the random bytes may be needed soon after a reboot.</p>
<ul>
<li>We can&rsquo;t rely on network I/O to generate random bytes. The client may be using a crossover cable.</li>
<li>We don&rsquo;t get a lot of entropy from disks, as the disks are only used when requested by the user.</li>
<li>We can&rsquo;t rely on user interaction to generate random bytes.</li>
</ul>
<p>(REMOVED)</p>
    </div>

    <footer>
        <div class="tags">
            <a href="./tag/encryption.html">encryption</a>
        </div>
        <div class="pure-g post-footer">
            <div class="pure-u-1 pure-u-md-1-2">
                <div class="pure-g poster-info">
                    <div class="pure-u">
                        <a href="./author/ali-imran.html"><img src="//github.com/alipullup.png?size=120" alt=""></a>
                    </div>
                    <div class="pure-u-3-4">
                        <h3 class="author-name"><a href="./author/ali-imran.html">Ali Imran</a></h3>
                        <p class="author-description">
                          Software Engineer
                        </p>
                    </div>
                </div>
            </div>



        </div>


    </footer>


</div>



    <footer class="index-footer">

        <a href="./" title="Ali's Posts">Ali's Posts</a>
        <a href="/archives.html">Archives</a></li>
        <a href="/categories.html">Categories</a></li>
        <a href="/tags.html">Tags</a></li>
        <a href="./pages/about-me.html">About me</a>

    </footer>

</body>
</html>