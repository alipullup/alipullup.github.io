<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Ali's Posts</title><link href="https://alipullup.github.io/" rel="alternate"></link><link href="https://alipullup.github.io/feeds/all.atom.xml" rel="self"></link><id>https://alipullup.github.io/</id><updated>2016-11-20T00:00:00-05:00</updated><entry><title>Gigabit Ethernet Protocol</title><link href="https://alipullup.github.io/gigabit-ethernet-protocol.html" rel="alternate"></link><published>2016-11-20T00:00:00-05:00</published><updated>2016-11-20T00:00:00-05:00</updated><author><name>Ali Imran</name></author><id>tag:alipullup.github.io,2006-01-24:gigabit-ethernet-protocol.html</id><summary type="html">&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;p&gt;This document gives a brief overview of a UDP based data transfer protocol. The protocol was implemented on a Xilinx FPGA, and a portable C client running on a Windows or Linux machine.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bandwidth was managed by specifying an inter-packet gap (IPG) interval. The FPGA would send a data packet, wait the IPG amount, then send the next packet.&lt;/li&gt;
&lt;li&gt;Round-trip time (RTT) was determined using a timestamp embedded int he packets.&lt;/li&gt;
&lt;li&gt;Loss was detected using sequence numbers, and managed using NAK packets.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Packets arriving to the Xilinx FPGA are diverted to a control processor for handling,. We are not using a soft microprocessor in the FPGA. The FPGA is responsible for interfacing with the data store and sending data packets to the client.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;--Message--&amp;gt; FPGA &amp;lt;---&amp;gt; Microprocessor
              |
           Data Store
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We faced various challenged, but broadly we had to worry about:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Ensuring the control process had enough of a TCP/IP implementation to function on a company&amp;rsquo;s LAN.&lt;/li&gt;
&lt;li&gt;Making sure the control process could respond fast enough to client requests.&lt;/li&gt;
&lt;li&gt;Coding up the portable C client to run in user-space, while responding quickly to changing network conditions.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Of the above, (3) was the most difficult. Each client&amp;rsquo;s network is slightly different, and there are various things we have to manage:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Unpredictable disk I/O.  We have to know how much data is queued up by the operating system, by the driver, and in the disk queues.&lt;/li&gt;
&lt;li&gt;Unpredictable process scheduling. We decided to create a user-space client (not running as a kernel driver). In hindsight, it would&amp;rsquo;ve been better to invest the resources in creating some sort of driver. As it stands, the operating system may decide to run something else for 10 milliseconds.&lt;/li&gt;
&lt;li&gt;Unpredictable network conditions. We ended up suggesting the use of &lt;a href="https://en.wikipedia.org/wiki/Ethernet_flow_control"&gt;hardware-based flow control&lt;/a&gt; to deal with various sources of packet loss.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Overall, the most difficult customer questions were never &amp;ldquo;it doesn&amp;rsquo;t work&amp;rdquo;, they were always &amp;ldquo;why is it sometimes slow?&amp;rdquo;. &lt;/p&gt;
&lt;p&gt;To answer the &amp;ldquo;why is it slow&amp;rdquo; question, we ended up:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Adding tunable logging to the portable C client&lt;/li&gt;
&lt;li&gt;Adding a tunable set of counters to the portable C client&lt;/li&gt;
&lt;li&gt;Noticing &amp;ldquo;anomalies&amp;rdquo; in the client and logging them (e.g. sudden jump in RTT or loss)&lt;/li&gt;
&lt;li&gt;Creating various &amp;ldquo;dry run&amp;rdquo; and &amp;ldquo;simulated data&amp;rdquo; modes to test individual pieces of the client:&lt;ul&gt;
&lt;li&gt;A mode to benchmark and test the disk bandwidth.  Some times clients were running on a 5 year old laptop connected to a USB drive, when we recommended the latest blade server.&lt;/li&gt;
&lt;li&gt;A mode to benchmark and test the network bandwidth. Some cheap switches are terrible, and do bad things to packets.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Message Format&lt;/h1&gt;
&lt;p&gt;There are various messages: some go from the FPGA to the C client, others go from the C client to the FPGA. All messages share a common header.&lt;/p&gt;
&lt;h2&gt;General Header&lt;/h2&gt;
&lt;p&gt;Format of the general header:&lt;/p&gt;
&lt;table width="720"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;Field&lt;/p&gt;
&lt;/td&gt;
&lt;td width="81"&gt;
&lt;p&gt;Length (bytes)&lt;/p&gt;
&lt;/td&gt;
&lt;td width="464"&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;Version&lt;/p&gt;
&lt;/td&gt;
&lt;td width="81"&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td width="464"&gt;
&lt;p&gt;Identifies a protocol version. The first version of the protocol will be 0.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;Type&lt;/p&gt;
&lt;/td&gt;
&lt;td width="81"&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td width="464"&gt;
&lt;p&gt;Type of the message.&amp;nbsp; Currently we have the following types of messages defined:&lt;/p&gt;
&lt;p&gt;DATA(0) &amp;ndash; This message contains data.&lt;/p&gt;
&lt;p&gt;ACK(1) &amp;ndash; This is an acknowledgment message.&lt;/p&gt;
&lt;p&gt;NAK(2) &amp;ndash; This is a negative acknowledgment message.&lt;br /&gt; OPEN(3) &amp;ndash; This is an open message.&lt;/p&gt;
&lt;p&gt;CLOSE(4) &amp;ndash; This is a close message.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;Reserved&lt;/p&gt;
&lt;/td&gt;
&lt;td width="81"&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td width="464"&gt;
&lt;p&gt;Reserved bytes for future use.&amp;nbsp; Should be set to zero (0) when transmitted.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;/td&gt;
&lt;td width="81"&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;/td&gt;
&lt;td width="464"&gt;
&lt;p&gt;The rest of the message depends on the &lt;em&gt;Type&lt;/em&gt; field.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2&gt;Data Message&lt;/h2&gt;
&lt;p&gt;The DATA message is sent by the &lt;strong&gt;server to the client&lt;/strong&gt;.  It contains
a single block of data.&lt;/p&gt;
&lt;table width="720"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;td colspan="3" width="720"&gt;
&lt;p&gt;DATA Message Body&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;Field&lt;/p&gt;
&lt;/td&gt;
&lt;td width="114"&gt;
&lt;p&gt;Length (bytes)&lt;/p&gt;
&lt;/td&gt;
&lt;td width="431"&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;Estimated RTT (RTT)&lt;/p&gt;
&lt;/td&gt;
&lt;td width="114"&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td width="431"&gt;
&lt;p&gt;The current estimated RTT in microseconds.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;Block Number (BN)&lt;/p&gt;
&lt;/td&gt;
&lt;td width="114"&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td width="431"&gt;
&lt;p&gt;Contains a block number.&amp;nbsp; The data in the message belongs to this block.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;Time Stamp (TS)&lt;/p&gt;
&lt;/td&gt;
&lt;td width="114"&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td width="431"&gt;
&lt;p&gt;Time stamp sent by server to client.&amp;nbsp; This will be echoed back by the client in the ACK.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;Data (D)&lt;/p&gt;
&lt;/td&gt;
&lt;td width="114"&gt;
&lt;p&gt;Block_Size&lt;/p&gt;
&lt;/td&gt;
&lt;td width="431"&gt;
&lt;p&gt;Data for the block (BN). Note that this is a protocol constant.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2&gt;ACK Message&lt;/h2&gt;
&lt;p&gt;The ACK message is sent by the &lt;strong&gt;client to the server&lt;/strong&gt;.  It tells the
server how many blocks the client is ready to receive, and what blocks
the client has received thus far.&lt;/p&gt;
&lt;table width="720"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;td colspan="3" width="720"&gt;
&lt;p&gt;ACK &amp;nbsp;Message Body&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;Field&lt;/p&gt;
&lt;/td&gt;
&lt;td width="81"&gt;
&lt;p&gt;Length (bytes)&lt;/p&gt;
&lt;/td&gt;
&lt;td width="464"&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;Last In-order Block Received (LBR)&lt;/p&gt;
&lt;/td&gt;
&lt;td width="81"&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td width="464"&gt;
&lt;p&gt;This identifies the last in-order block received. The server assumes that every block coming before this has been received by the client.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;Time Stamp (TS)&lt;/p&gt;
&lt;/td&gt;
&lt;td width="81"&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td width="464"&gt;
&lt;p&gt;Time stamp of the DATA packet this ACK references.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;Window Size (WS)&lt;/p&gt;
&lt;/td&gt;
&lt;td width="81"&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td width="464"&gt;
&lt;p&gt;The number of &lt;em&gt;DATA&lt;/em&gt; messages the receiver is ready to receive.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;Reserved&lt;/p&gt;
&lt;/td&gt;
&lt;td width="81"&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td width="464"&gt;
&lt;p&gt;Reserved bytes for future use.&amp;nbsp; Should be set to zero (0) when transmitted.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2&gt;NAK Message&lt;/h2&gt;
&lt;p&gt;The NAK message is sent by the &lt;strong&gt;client to the server&lt;/strong&gt;.  It tells the
server if any block has been lost.&lt;/p&gt;
&lt;table width="720"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;td colspan="3" width="720"&gt;
&lt;p&gt;NAK &amp;nbsp;Message Body&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;Field&lt;/p&gt;
&lt;/td&gt;
&lt;td width="81"&gt;
&lt;p&gt;Length (bytes)&lt;/p&gt;
&lt;/td&gt;
&lt;td width="464"&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;Blocks Lost&lt;/p&gt;
&lt;/td&gt;
&lt;td width="81"&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td width="464"&gt;
&lt;p&gt;How many blocks are lost.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;Block Numbers&lt;/p&gt;
&lt;/td&gt;
&lt;td width="81"&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;/td&gt;
&lt;td width="464"&gt;
&lt;p&gt;A list of all the block numbers that are lost.&amp;nbsp; The length of this in bytes will be 2 * Blocks Lost (each block is represented using two bytes).&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="175"&gt;
&lt;p&gt;End Marker&lt;/p&gt;
&lt;/td&gt;
&lt;td width="81"&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td width="464"&gt;
&lt;p&gt;This special block number marks the end of the the packet and will be send to &lt;strong&gt;End_Block_Marker&lt;/strong&gt;.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1&gt;Sender Algorithm&lt;/h1&gt;
&lt;p&gt;Omitted&lt;/p&gt;
&lt;h1&gt;Receiver Algorithm&lt;/h1&gt;
&lt;p&gt;Omitted&lt;/p&gt;
&lt;h1&gt;Protocol atop UDP&lt;/h1&gt;
&lt;p&gt;When the protocol is implemented on top of IP/UDP, the full PDU will look something like:&lt;/p&gt;
&lt;table width="721"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;Protocol&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;Field&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;Offset&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;Length (bytes)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;IP&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;Version + IHL&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;IP&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;TOS&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;IP&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;Total Length&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;IP&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;Identification&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;IP&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;Flags + Fragment Offset&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;IP&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;Time To Live&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;IP&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;Protocol (17, UDP)&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;IP&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;Header Checksum&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;IP&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;Source IP Address&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;IP&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;Dest. IP Address&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;IP&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;Options and Padding&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;20&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;UDP&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;Source Port&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;20&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;UDP&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;Destination Port&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;22&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;UDP&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;Length&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;24&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;UDP&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;Checksum&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;26&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;LR&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;Version&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;28&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;LR&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;Type&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;29&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width="104"&gt;
&lt;p&gt;LR&lt;/p&gt;
&lt;/td&gt;
&lt;td width="325"&gt;
&lt;p&gt;Reserved&lt;/p&gt;
&lt;/td&gt;
&lt;td width="123"&gt;
&lt;p&gt;30&lt;/p&gt;
&lt;/td&gt;
&lt;td width="170"&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan="4" width="721"&gt;
&lt;p&gt;&lt;strong&gt;Type&lt;/strong&gt; specific data.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This adds up to a total of 32 + 10 bytes for a DATA packet, not including the data.&lt;/p&gt;
&lt;h1&gt;Protocol Performance&lt;/h1&gt;
&lt;p&gt;Assuming that we&amp;rsquo;re carrying the protocol atop UDP, and that:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Ethernet Overhead   ← 8 + 14 → 22 bytes 
IP + UDP Overhead   ← 20 + 8 → 28 bytes
Protocol Header Size    ← 4 + 2 + 4 → 10 bytes
Protocol Data Size  ← Block_Size → 1440
Ethernet FCS        ← 4 bytes
Ethernet IPG        ← 12 bytes

Total Overhead  ← 22 + 28 + 10 + 4 + 12 → 76 bytes
Total Bytes     ← Total Overhead + Block_Size
            → 76 + 1440 → 1516

Bandwidth       ← 10^9 bits / second
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The efficiency will be:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(Data sent in time T) / (Total data sent in time T)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Assuming we can send&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(8 * Max_Window_Size * Block_Size)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;bits in time T, the actual amount on the wire is&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(8 * Max_Window_Size * Total Bytes)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and note that we&amp;rsquo;ll have to wait one round-time trip (RTT) to for the
remote to ACK these bytes, which we can throw in our equation as
(RTT * BandWidth) bits.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(8*MaxWindowSize*BlockSize)/(8*MaxWindowSize*TotalBytes+RTT*BandWidth)
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Calculations&lt;/h2&gt;
&lt;p&gt;Here are some calculations given various window sizes, block sizes,
and round-trip times&lt;/p&gt;
&lt;p&gt;(Omitted)&lt;/p&gt;
&lt;h2&gt;Real Time Requirements&lt;/h2&gt;
&lt;p&gt;To maintain optimal throughput, the server has to send ACK requests
every so often.  Specifically, the server should be able to send an
ACK packet every &lt;code&gt;Max_Window_Size / 2&lt;/code&gt; packets.  Here are some numbers
for a given window size and block size:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Window Size&lt;/th&gt;
&lt;th&gt;Block Size&lt;/th&gt;
&lt;th&gt;Time to React&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1024&lt;/td&gt;
&lt;td&gt;1440&lt;/td&gt;
&lt;td&gt;0.0059&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1024&lt;/td&gt;
&lt;td&gt;8920&lt;/td&gt;
&lt;td&gt;0.0365&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2048&lt;/td&gt;
&lt;td&gt;8920&lt;/td&gt;
&lt;td&gt;0.0731&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The time given about is for 1000 Mbit/s speeds.&lt;/p&gt;
&lt;h2&gt;IPG Calculations&lt;/h2&gt;
&lt;p&gt;Setting the inter-packet gap between packets can be used to scale the
bandwidth.&lt;/p&gt;
&lt;p&gt;Bandwidth is the amount of data sent in some period of time.  The
normal time taken (without any IPG) to send data is simply:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;DataSize / BandWidth
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;By adding an inter packet gap, the time taken increases by IPG
seconds.  Thus, the achieved bandwidth is:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;AchievedBandWidth =  DataSize / (DataSize / BandWidth + IPG)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Solving for IPG, we get the equation:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-DataSize(AchievedBandWidth-BandWidth)/(AchievedBandWidth*BandWidth)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here are some calculations about required IPG values to achieve a given bandwidth:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Data Size&lt;/th&gt;
&lt;th&gt;Bandwidth&lt;/th&gt;
&lt;th&gt;Achieved&lt;/th&gt;
&lt;th&gt;IPG (us)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1500&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1500&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;800&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1500&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Packet Loss&lt;/h2&gt;
&lt;p&gt;(Omitted)&lt;/p&gt;</summary><category term="programming"></category><category term="networking"></category><category term="protocol"></category></entry></feed>